// Advent of Code 2015, Day 10: "Elves Look, Elves Say"
// https://adventofcode.com/2015/day/10

// Applies the look-and-say algorithm to the given input buffer and stores the result in the given output buffer.
// The details of the look-and-say algorithm are documented on the apply_look_and_say function.
fn apply_look_and_say_to_buffer(input: &[char], output: &mut Vec<char>) {
    let mut current_number: Option<char> = None;
    let mut current_number_count = 0;
    for c in input {
        // If the current number is different from the previous number, output the previous number and its count.
        if current_number.is_none() || current_number.unwrap() != *c {
            // If there is a current number, output it and its count.
            if let Some(some_current_number) = current_number {
                output.push(std::char::from_digit(current_number_count, 10).unwrap());
                output.push(some_current_number);
            }

            // Reset the current number and count.
            current_number = Some(*c);
            current_number_count = 1;
        } else {
            current_number_count += 1;
        }
    }

    // Output the last number and its count.
    output.push(std::char::from_digit(current_number_count, 10).unwrap());
    output.push(current_number.unwrap());
}

// Returns the string generated by applying the look-and-say algorithm to the given input string
// the given number of times.
// The look-and-say algorithm is as follows:
//   For each character in the input string, count the number of consecutive occurrences of that
//   character, then append that count followed by the character to the output string.
fn apply_look_and_say(input: &str, iterations: usize) -> String {
    // Allocate two working character buffers to use while applying the look-and-say algorithm.
    // This avoids many allocations and deallocations of strings during the algorithm,
    // which can be very expensive.
    // Use a heuristic to estimate an efficient starting capacity for the buffers based on the
    // idea that the output string may be up to twice as long as the input string for a given application
    // of the look-and-say algorithm, and the number of iterations will impact the length of the
    // final output stirng.
    let estimated_output_length = input.len() * 2 * iterations;
    let mut input_buffer = input.chars().collect::<Vec<_>>();
    input_buffer.reserve(estimated_output_length);
    let mut output_buffer = Vec::with_capacity(estimated_output_length);
    for _ in 0..iterations {
        apply_look_and_say_to_buffer(&input_buffer, &mut output_buffer);
        std::mem::swap(&mut input_buffer, &mut output_buffer);
        output_buffer.clear();
    }
    input_buffer.iter().collect()
}

fn solve(input: &str, log_fn: Option<fn(&str)>) -> (String, String) {
    // Part 1: Find the length of the string after applying the look-and-say algorithm 40 times.
    let mut string_after_40_iterations;
    // If logging is enabled, log intermediate results. Otherwise, just apply the look-and-say
    // algorithm 40 times.
    if let Some(log_fn) = log_fn {
        string_after_40_iterations = input.to_string();
        for i in 0..10 {
            string_after_40_iterations = apply_look_and_say(&string_after_40_iterations, 1);
            log_fn(&format!(
                "String after {} iterations: {}",
                i + 1,
                string_after_40_iterations
            ));
        }

        for i in 10..40 {
            string_after_40_iterations = apply_look_and_say(&string_after_40_iterations, 1);
            log_fn(&format!(
                "Length of string after {} iterations: {}",
                i + 1,
                string_after_40_iterations.len()
            ));
        }
    } else {
        string_after_40_iterations = apply_look_and_say(input, 40);
    }
    let part1_result = string_after_40_iterations.len();

    // Part 2: Find the length of the string after applying the look-and-say algorithm 50 times.
    let string_after_50_iterations = apply_look_and_say(&string_after_40_iterations, 10);
    let part2_result = string_after_50_iterations.len();

    (part1_result.to_string(), part2_result.to_string())
}

#[linkme::distributed_slice(crate::SOLUTIONS)]
static SOLUTION: crate::Solution = crate::Solution::new(2015, 10, solve);
